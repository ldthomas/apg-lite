const Parser=function(){const e=identifiers,t=utilities,n=this,s="parser.js: Parser(): ";n.ast=void 0,n.stats=void 0,n.trace=void 0,n.callbacks=[];let r,a,i,o,h,c,l,d=0,p=0,T=0,g=0,m=0,u=new function(){this.state=e.ACTIVE,this.phraseLength=0,this.refresh=()=>{this.state=e.ACTIVE,this.phraseLength=0}};n.parse=(f,A,E,M)=>{const w=`${s}parse(): `;d=0,p=0,T=0,g=0,m=0,r=void 0,a=void 0,i=void 0,o=void 0,u.refresh(),h=void 0,c=void 0,l=void 0,o=t.stringToChars(E),r=f.rules,a=f.udts;const L=A.toLowerCase();let $;for(const e in r)if(L===r[e].lower){$=r[e].index;break}if(void 0===$)throw new Error(`${w}start rule name '${startRule}' not recognized`);(()=>{const e=`${s}initializeCallbacks(): `;let t,i;for(h=[],c=[],t=0;t<r.length;t+=1)h[t]=void 0;for(t=0;t<a.length;t+=1)c[t]=void 0;const o=[];for(t=0;t<r.length;t+=1)o.push(r[t].lower);for(t=0;t<a.length;t+=1)o.push(a[t].lower);for(const s in n.callbacks){if(t=o.indexOf(s.toLowerCase()),t<0)throw new Error(`${e}syntax callback '${s}' not a rule or udt name`);if(i=n.callbacks[s]?n.callbacks[s]:void 0,"function"!=typeof i&&void 0!==i)throw new Error(`${e}syntax callback[${s}] must be function reference or falsy)`);t<r.length?h[t]=i:c[t-r.length]=i}})(),n.trace&&n.trace.init(r,a,o),n.stats&&n.stats.init(r,a),n.ast&&n.ast.init(r,a,o),l=M,i=[{type:e.RNM,index:$}],x(0,0),i=void 0;let C=!1;switch(u.state){case e.ACTIVE:throw new Error(`${w}final state should never be 'ACTIVE'`);case e.NOMATCH:C=!1;break;case e.EMPTY:case e.MATCH:C=u.phraseLength===o.length;break;default:throw new Error("unrecognized state")}return{success:C,state:u.state,stateName:e.idName(u.state),length:o.length,matched:u.phraseLength,maxMatched:m,maxTreeDepth:T,nodeHits:g}};const f=(t,n,r,a)=>{if(n.phraseLength>r){let e=`${s}opRNM(${t.name}): callback function error: `;throw e+=`sysData.phraseLength: ${n.phraseLength}`,e+=` must be <= remaining chars: ${r}`,new Error(e)}switch(n.state){case e.ACTIVE:if(!a)throw new Error(`${s}opRNM(${t.name}): callback function return error. ACTIVE state not allowed.`);break;case e.EMPTY:n.phraseLength=0;break;case e.MATCH:0===n.phraseLength&&(n.state=e.EMPTY);break;case e.NOMATCH:n.phraseLength=0;break;default:throw new Error(`${s}opRNM(${t.name}): callback function return error. Unrecognized return state: ${n.state}`)}},A=(t,h)=>{let p,T,g;const m=i[t],f=a[m.index];u.UdtIndex=f.index,d||(g=n.ast&&n.ast.udtDefined(m.index),g&&(T=r.length+m.index,p=n.ast.getLength(),n.ast.down(T,f.name)));const A=o.length-h;c[m.index](u,o,h,l),((t,n,r)=>{if(n.phraseLength>r){let e=`${s}opUDT(${t.name}): callback function error: `;throw e+=`sysData.phraseLength: ${n.phraseLength}`,e+=` must be <= remaining chars: ${r}`,new Error(e)}switch(n.state){case e.ACTIVE:throw new Error(`${s}opUDT(${t.name}) ACTIVE state return not allowed.`);case e.EMPTY:if(!t.empty)throw new Error(`${s}opUDT(${t.name}) may not return EMPTY.`);n.phraseLength=0;break;case e.MATCH:if(0===n.phraseLength){if(!t.empty)throw new Error(`${s}opUDT(${t.name}) may not return EMPTY.`);n.state=e.EMPTY}break;case e.NOMATCH:n.phraseLength=0;break;default:throw new Error(`${s}opUDT(${t.name}): callback function return error. Unrecognized return state: ${n.state}`)}})(f,u,A),d||g&&(u.state===e.NOMATCH?n.ast.setLength(p):n.ast.up(T,f.name,h,u.phraseLength))},x=(t,a)=>{const c=`${s}opExecute(): `,E=i[t];switch(g+=1,p>T&&(T=p),p+=1,u.refresh(),n.trace&&n.trace.down(E,a),E.type){case e.ALT:((t,n)=>{const s=i[t];for(let t=0;t<s.children.length&&(x(s.children[t],n),u.state===e.NOMATCH);t+=1);})(t,a);break;case e.CAT:((t,s)=>{let r,a,o,h;const c=i[t];n.ast&&(a=n.ast.getLength()),r=!0,o=s,h=0;for(let t=0;t<c.children.length;t+=1){if(x(c.children[t],o),u.state===e.NOMATCH){r=!1;break}o+=u.phraseLength,h+=u.phraseLength}r?(u.state=0===h?e.EMPTY:e.MATCH,u.phraseLength=h):(u.state=e.NOMATCH,u.phraseLength=0,n.ast&&n.ast.setLength(a))})(t,a);break;case e.REP:((t,s)=>{let r,a,h,c;const l=i[t];if(0===l.max)return u.state=e.EMPTY,void(u.phraseLength=0);for(a=s,h=0,c=0,n.ast&&(r=n.ast.getLength());!(a>=o.length)&&(x(t+1,a),u.state!==e.NOMATCH)&&u.state!==e.EMPTY&&(c+=1,h+=u.phraseLength,a+=u.phraseLength,c!==l.max););u.state===e.EMPTY||c>=l.min?(u.state=0===h?e.EMPTY:e.MATCH,u.phraseLength=h):(u.state=e.NOMATCH,u.phraseLength=0,n.ast&&n.ast.setLength(r))})(t,a);break;case e.RNM:((t,s)=>{let a,c,p;const T=i[t],g=r[T.index],m=h[g.index];if(d||(c=n.ast&&n.ast.ruleDefined(T.index),c&&(a=n.ast.getLength(),n.ast.down(T.index,r[T.index].name))),m){const t=o.length-s;m(u,o,s,l),f(g,u,t,!0),u.state===e.ACTIVE&&(p=i,i=g.opcodes,x(0,s),i=p,m(u,o,s,l),f(g,u,t,!1))}else p=i,i=g.opcodes,x(0,s,u),i=p;d||c&&(u.state===e.NOMATCH?n.ast.setLength(a):n.ast.up(T.index,g.name,s,u.phraseLength))})(t,a);break;case e.TRG:((t,n)=>{const s=i[t];u.state=e.NOMATCH,n<o.length&&s.min<=o[n]&&o[n]<=s.max&&(u.state=e.MATCH,u.phraseLength=1)})(t,a);break;case e.TBS:((t,n)=>{const s=i[t],r=s.string.length;if(u.state=e.NOMATCH,n+r<=o.length){for(let e=0;e<r;e+=1)if(o[n+e]!==s.string[e])return;u.state=e.MATCH,u.phraseLength=r}})(t,a);break;case e.TLS:((t,n)=>{let s;const r=i[t];u.state=e.NOMATCH;const a=r.string.length;if(0!==a){if(n+a<=o.length){for(let e=0;e<a;e+=1)if(s=o[n+e],s>=65&&s<=90&&(s+=32),s!==r.string[e])return;u.state=e.MATCH,u.phraseLength=a}}else u.state=e.EMPTY})(t,a);break;case e.UDT:A(t,a);break;case e.AND:((t,n)=>{switch(d+=1,x(t+1,n),d-=1,u.phraseLength=0,u.state){case e.EMPTY:case e.MATCH:u.state=e.EMPTY;break;case e.NOMATCH:u.state=e.NOMATCH;break;default:throw new Error(`opAND: invalid state ${u.state}`)}})(t,a);break;case e.NOT:((t,n)=>{switch(d+=1,x(t+1,n),d-=1,u.phraseLength=0,u.state){case e.EMPTY:case e.MATCH:u.state=e.NOMATCH;break;case e.NOMATCH:u.state=e.EMPTY;break;default:throw new Error(`opNOT: invalid state ${u.state}`)}})(t,a);break;default:throw new Error(`${c}unrecognized operator`)}d||a+u.phraseLength>m&&(m=a+u.phraseLength),n.stats&&n.stats.collect(E,u),n.trace&&n.trace.up(E,u.state,a,u.phraseLength),p-=1}},Ast=function(){const e=identifiers,t=utilities,n=this;let s,r,a,i=0;const o=[],h=[],c=[];function l(e){let t="";for(;e-- >0;)t+=" ";return t}n.callbacks=[],n.init=(e,t,l)=>{let d;h.length=0,c.length=0,i=0,s=e,r=t,a=l;const p=[];for(d=0;d<s.length;d+=1)p.push(s[d].lower);for(d=0;d<r.length;d+=1)p.push(r[d].lower);for(i=s.length+r.length,d=0;d<i;d+=1)o[d]=void 0;for(const e in n.callbacks){const t=e.toLowerCase();if(d=p.indexOf(t),d<0)throw new Error(`parser.js: Ast()): init: node '${e}' not a rule or udt name`);o[d]=n.callbacks[e]}},n.ruleDefined=e=>!!o[e],n.udtDefined=e=>!!o[s.length+e],n.down=(t,n)=>{const s=c.length;return h.push(s),c.push({name:n,thisIndex:s,thatIndex:void 0,state:e.SEM_PRE,callbackIndex:t,phraseIndex:void 0,phraseLength:void 0,stack:h.length}),s},n.up=(t,n,s,r)=>{const a=c.length,i=h.pop();return c.push({name:n,thisIndex:a,thatIndex:i,state:e.SEM_POST,callbackIndex:t,phraseIndex:s,phraseLength:r,stack:h.length}),c[i].thatIndex=a,c[i].phraseIndex=s,c[i].phraseLength=r,a},n.translate=t=>{let n,s;for(let r=0;r<c.length;r+=1)s=c[r],n=o[s.callbackIndex],n&&(s.state===e.SEM_PRE?n(e.SEM_PRE,a,s.phraseIndex,s.phraseLength,t):n&&n(e.SEM_POST,a,s.phraseIndex,s.phraseLength,t))},n.setLength=e=>{c.length=e,h.length=e>0?c[e-1].stack:0},n.getLength=()=>c.length,n.toXml=()=>{let n="",s=0;return n+='<?xml version="1.0" encoding="utf-8"?>\n',n+=`<root nodes="${c.length/2}" characters="${a.length}">\n`,n+="\x3c!-- input string --\x3e\n",n+=l(s+2),n+=t.charsToString(a),n+="\n",c.forEach((r=>{r.state===e.SEM_PRE?(s+=1,n+=l(s),n+=`<node name="${r.name}" index="${r.phraseIndex}" length="${r.phraseLength}">\n`,n+=l(s+2),n+=t.charsToString(a,r.phraseIndex,r.phraseLength),n+="\n"):(n+=l(s),n+=`</node>\x3c!-- name="${r.name}" --\x3e\n`,s-=1)})),n+="</root>\n",n}},Trace=function(){const e=identifiers,t=utilities,n="parser.js: Trace(): ";let s,r,a,i="",o=0;const h=this,c=e=>{let t="",n=0;if(e>=0)for(;e--;)n+=1,5===n?(t+="|",n=0):t+=".";return t};h.init=(e,t,n)=>{r=e,a=t,s=n};const l=s=>{let i;switch(s.type){case e.ALT:i="ALT";break;case e.CAT:i="CAT";break;case e.REP:i=s.max===1/0?`REP(${s.min},inf)`:`REP(${s.min},${s.max})`;break;case e.RNM:i=`RNM(${r[s.index].name})`;break;case e.TRG:i=`TRG(${s.min},${s.max})`;break;case e.TBS:i=s.string.length>6?`TBS(${t.charsToString(s.string,0,3)}...)`:`TBS(${t.charsToString(s.string,0,6)})`;break;case e.TLS:i=s.string.length>6?`TLS(${t.charsToString(s.string,0,3)}...)`:`TLS(${t.charsToString(s.string,0,6)})`;break;case e.UDT:i=`UDT(${a[s.index].name})`;break;case e.AND:i="AND";break;case e.NOT:i="NOT";break;default:throw new Error(`${n}Trace: opName: unrecognized opcode`)}return i};h.down=(e,n)=>{const r=c(o),a=Math.min(100,s.length-n);let h=t.charsToString(s,n,a);a<s.length-n&&(h+="..."),h=`${r}|-|[${l(e)}]${h}\n`,i+=h,o+=1},h.up=(r,a,h,d)=>{const p=`${n}trace.up: `;o-=1;const T=c(o);let g,m,u;switch(a){case e.EMPTY:u="|E|",m="''";break;case e.MATCH:u="|M|",g=Math.min(100,d),m=g<d?`'${t.charsToString(s,h,g)}...'`:`'${t.charsToString(s,h,g)}'`;break;case e.NOMATCH:u="|N|",m="";break;default:throw new Error(`${p} unrecognized state`)}m=`${T}${u}[${l(r)}]${m}\n`,i+=m},h.displayTrace=()=>i},Stats=function(){const e=identifiers;let t,n,s;const r=[],a=[],i=[];this.init=(e,s)=>{t=e,n=s,p()},this.collect=(t,n)=>{T(s,n.state,n.phraseLength),T(r[t.type],n.state,n.phraseLength),t.type===e.RNM&&T(a[t.index],n.state,n.phraseLength),t.type===e.UDT&&T(i[t.index],n.state,n.phraseLength)},this.displayStats=()=>{let t="";const n={match:0,empty:0,nomatch:0,total:0},s=(e,t,s,r,a)=>{n.match+=t,n.empty+=s,n.nomatch+=r,n.total+=a;return`${e} | ${o(t)} | ${o(s)} | ${o(r)} | ${o(a)} |\n`};return t+="          OPERATOR STATS\n",t+="      |   MATCH |   EMPTY | NOMATCH |   TOTAL |\n",t+=s("  ALT",r[e.ALT].match,r[e.ALT].empty,r[e.ALT].nomatch,r[e.ALT].total),t+=s("  CAT",r[e.CAT].match,r[e.CAT].empty,r[e.CAT].nomatch,r[e.CAT].total),t+=s("  REP",r[e.REP].match,r[e.REP].empty,r[e.REP].nomatch,r[e.REP].total),t+=s("  RNM",r[e.RNM].match,r[e.RNM].empty,r[e.RNM].nomatch,r[e.RNM].total),t+=s("  TRG",r[e.TRG].match,r[e.TRG].empty,r[e.TRG].nomatch,r[e.TRG].total),t+=s("  TBS",r[e.TBS].match,r[e.TBS].empty,r[e.TBS].nomatch,r[e.TBS].total),t+=s("  TLS",r[e.TLS].match,r[e.TLS].empty,r[e.TLS].nomatch,r[e.TLS].total),t+=s("  UDT",r[e.UDT].match,r[e.UDT].empty,r[e.UDT].nomatch,r[e.UDT].total),t+=s("  AND",r[e.AND].match,r[e.AND].empty,r[e.AND].nomatch,r[e.AND].total),t+=s("  NOT",r[e.NOT].match,r[e.NOT].empty,r[e.NOT].nomatch,r[e.NOT].total),t+=s("TOTAL",n.match,n.empty,n.nomatch,n.total),t},this.displayHits=e=>{let t="";const n=(e,t,n,r,a)=>{s.match+=e,s.empty+=t,s.nomatch+=n,s.total+=r;return`| ${o(e)} | ${o(t)} | ${o(n)} | ${o(r)} | ${a}\n`};"string"==typeof e&&"a"===e.toLowerCase()[0]?(a.sort(h),i.sort(h),t+="    RULES/UDTS ALPHABETICALLY\n"):"string"==typeof e&&"i"===e.toLowerCase()[0]?(a.sort(l),i.sort(l),t+="    RULES/UDTS BY INDEX\n"):(a.sort(c),i.sort(c),t+="    RULES/UDTS BY HIT COUNT\n"),t+="|   MATCH |   EMPTY | NOMATCH |   TOTAL | NAME\n";for(let e=0;e<a.length;e+=1){let s=a[e];s.total&&(t+=n(s.match,s.empty,s.nomatch,s.total,s.name))}for(let e=0;e<i.length;e+=1){let s=i[e];s.total&&(t+=n(s.match,s.empty,s.nomatch,s.total,s.name))}return t};const o=e=>e<10?`      ${e}`:e<100?`     ${e}`:e<1e3?`    ${e}`:e<1e4?`   ${e}`:e<1e5?`  ${e}`:e<1e6?` ${e}`:`${e}`,h=(e,t)=>e.lower<t.lower?-1:e.lower>t.lower?1:0,c=(e,t)=>e.total<t.total?1:e.total>t.total?-1:h(e,t),l=(e,t)=>e.index<t.index?-1:e.index>t.index?1:0,d=function(){this.empty=0,this.match=0,this.nomatch=0,this.total=0},p=()=>{r.length=0,s=new d,r[e.ALT]=new d,r[e.CAT]=new d,r[e.REP]=new d,r[e.RNM]=new d,r[e.TRG]=new d,r[e.TBS]=new d,r[e.TLS]=new d,r[e.UDT]=new d,r[e.AND]=new d,r[e.NOT]=new d,a.length=0;for(let e=0;e<t.length;e+=1)a.push({empty:0,match:0,nomatch:0,total:0,name:t[e].name,lower:t[e].lower,index:t[e].index});if(n.length>0){i.length=0;for(let e=0;e<n.length;e+=1)i.push({empty:0,match:0,nomatch:0,total:0,name:n[e].name,lower:n[e].lower,index:n[e].index})}},T=(t,n)=>{switch(t.total+=1,n){case e.EMPTY:t.empty+=1;break;case e.MATCH:t.match+=1;break;case e.NOMATCH:t.nomatch+=1;break;default:throw new Error(`parser.js: Stats(): collect(): incStat(): unrecognized state: ${n}`)}}},utilities={stringToChars:e=>[...e].map((e=>e.codePointAt(0))),charsToString:(e,t,n)=>{let s=e;for(;!(void 0===t||t<0);){if(void 0===n){s=e.slice(t);break}if(n<=0)return"";s=e.slice(t,t+n);break}return String.fromCodePoint(...s)}},identifiers={ALT:1,CAT:2,REP:3,RNM:4,TRG:5,TBS:6,TLS:7,UDT:11,AND:12,NOT:13,ACTIVE:100,MATCH:101,EMPTY:102,NOMATCH:103,SEM_PRE:200,SEM_POST:201,SEM_OK:300,idName:e=>{switch(e){case identifiers.ALT:return"ALT";case identifiers.CAT:return"CAT";case identifiers.REP:return"REP";case identifiers.RNM:return"RNM";case identifiers.TRG:return"TRG";case identifiers.TBS:return"TBS";case identifiers.TLS:return"TLS";case identifiers.UDT:return"UDT";case identifiers.AND:return"AND";case identifiers.NOT:return"NOT";case identifiers.ACTIVE:return"ACTIVE";case identifiers.EMPTY:return"EMPTY";case identifiers.MATCH:return"MATCH";case identifiers.NOMATCH:return"NOMATCH";case identifiers.SEM_PRE:return"SEM_PRE";case identifiers.SEM_POST:return"SEM_POST";case identifiers.SEM_OK:return"SEM_OK";default:return"UNRECOGNIZED STATE"}}},Grammar=function(){this.grammarObject="grammarObject",this.rules=[],this.rules[0]={name:"float",lower:"float",index:0,isBkr:!1},this.rules[1]={name:"sign",lower:"sign",index:1,isBkr:!1},this.rules[2]={name:"decimal",lower:"decimal",index:2,isBkr:!1},this.rules[3]={name:"integer",lower:"integer",index:3,isBkr:!1},this.rules[4]={name:"dot",lower:"dot",index:4,isBkr:!1},this.rules[5]={name:"fraction",lower:"fraction",index:5,isBkr:!1},this.rules[6]={name:"exponent",lower:"exponent",index:6,isBkr:!1},this.rules[7]={name:"esign",lower:"esign",index:7,isBkr:!1},this.rules[8]={name:"exp",lower:"exp",index:8,isBkr:!1},this.udts=[],this.rules[0].opcodes=[],this.rules[0].opcodes[0]={type:2,children:[1,3,4]},this.rules[0].opcodes[1]={type:3,min:0,max:1},this.rules[0].opcodes[2]={type:4,index:1},this.rules[0].opcodes[3]={type:4,index:2},this.rules[0].opcodes[4]={type:3,min:0,max:1},this.rules[0].opcodes[5]={type:4,index:6},this.rules[1].opcodes=[],this.rules[1].opcodes[0]={type:1,children:[1,2]},this.rules[1].opcodes[1]={type:7,string:[43]},this.rules[1].opcodes[2]={type:7,string:[45]},this.rules[2].opcodes=[],this.rules[2].opcodes[0]={type:1,children:[1,8]},this.rules[2].opcodes[1]={type:2,children:[2,3]},this.rules[2].opcodes[2]={type:4,index:3},this.rules[2].opcodes[3]={type:3,min:0,max:1},this.rules[2].opcodes[4]={type:2,children:[5,6]},this.rules[2].opcodes[5]={type:4,index:4},this.rules[2].opcodes[6]={type:3,min:0,max:1},this.rules[2].opcodes[7]={type:4,index:5},this.rules[2].opcodes[8]={type:2,children:[9,10]},this.rules[2].opcodes[9]={type:4,index:4},this.rules[2].opcodes[10]={type:4,index:5},this.rules[3].opcodes=[],this.rules[3].opcodes[0]={type:3,min:1,max:1/0},this.rules[3].opcodes[1]={type:5,min:48,max:57},this.rules[4].opcodes=[],this.rules[4].opcodes[0]={type:7,string:[46]},this.rules[5].opcodes=[],this.rules[5].opcodes[0]={type:3,min:1,max:1/0},this.rules[5].opcodes[1]={type:5,min:48,max:57},this.rules[6].opcodes=[],this.rules[6].opcodes[0]={type:2,children:[1,2,4]},this.rules[6].opcodes[1]={type:7,string:[101]},this.rules[6].opcodes[2]={type:3,min:0,max:1},this.rules[6].opcodes[3]={type:4,index:7},this.rules[6].opcodes[4]={type:4,index:8},this.rules[7].opcodes=[],this.rules[7].opcodes[0]={type:1,children:[1,2]},this.rules[7].opcodes[1]={type:7,string:[43]},this.rules[7].opcodes[2]={type:7,string:[45]},this.rules[8].opcodes=[],this.rules[8].opcodes[0]={type:3,min:1,max:1/0},this.rules[8].opcodes[1]={type:5,min:48,max:57},this.toString=function(){let e="";return e+=";\n",e+="; floating point number\n",e+=";\n",e+="float    = [sign] decimal [exponent]\n",e+='sign     = "+" / "-"\n',e+="decimal  = integer [dot [fraction]]\n",e+="           / dot fraction\n",e+="integer  = 1*%d48-57\n",e+='dot      = "."\n',e+="fraction = 1*%d48-57\n",e+='exponent = "e" [esign] exp\n',e+='esign    = "+" / "-"\n',e+="exp      = 1*%d48-57\n",';\n; floating point number\n;\nfloat    = [sign] decimal [exponent]\nsign     = "+" / "-"\ndecimal  = integer [dot [fraction]]\n           / dot fraction\ninteger  = 1*%d48-57\ndot      = "."\nfraction = 1*%d48-57\nexponent = "e" [esign] exp\nesign    = "+" / "-"\nexp      = 1*%d48-57\n'}},parser=new Parser,grammar=new Grammar,id=identifiers,utils=utilities;$("#grammar-bnf").html(grammar.toString()),parser.callbacks.float=(e,t,n,s)=>{switch(e.state){case id.ACTIVE:s.float="",s.sign="",s.decimal="",s.exponent="";break;case id.MATCH:s.float=utils.charsToString(t,n,e.phraseLength)}},parser.callbacks.sign=(e,t,n,s)=>{e.state===id.MATCH&&(s.sign=utils.charsToString(t,n,e.phraseLength))},parser.callbacks.decimal=(e,t,n,s)=>{e.state===id.MATCH&&(s.decimal=utils.charsToString(t,n,e.phraseLength))},parser.callbacks.exponent=(e,t,n,s)=>{e.state===id.MATCH&&(s.exponent=utils.charsToString(t,n,e.phraseLength))};const data={},parseNumber=()=>{const e=$("#string").val(),t=parser.parse(grammar,"float",e,data);$("#result").html("Parser Result<br>"+JSON.stringify(t));let n="";t.success?(n+="Parsed Floating Point Number Parts\n",n+=`    sign: ${data.sign}\n`,n+=` decimal: ${data.decimal}\n`,n+=`exponent: ${data.exponent}\n`):n+="Invalid Floating Point Number\n",$("#values").html(n)};$(document).ready((()=>{$("#parse").click(parseNumber),$("#string").val("+1.23E-10")}));